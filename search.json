[{"title":"树","url":"/2024/03/14/树/","content":"\n[树的demo](https://github.com/seadeemo/algorithm-demo/tree/main/tree-demo)\n\n> 树由节点构成,也可以没有节点,称为空树\n\n> 一些基本概念：\n>\n> 根节点、子节点\n>\n> 节点的度：即子节点的个数\n>\n> 叶子节点：度为0的节点\n\n### 1.1 二叉树\n\n#### 1.1.1 二叉树的遍历\n\n> 一颗二叉树,可以分解为根节点,左子树,右子树 三个部分\n\n> 二叉树的遍历\n>\n> 1. 先序遍历(先根遍历) ---> 根节点 左子树 右子树\n> 2. 中序遍历(中根遍历) ---> 左子树 根节点 右子树\n> 3. 后序遍历(后根遍历) ---> 左子树 右子树 根节点\n\n#### 1.1.2 满二叉树,完全二叉树\n\n> 满二叉树:深度为k且节点数2^k-1\n\n> 完全二叉树:一棵深度为k的完全二叉树自上而下、自左到右的给每一个节点编号，其每一个节点的编号与一棵深度为k的满二叉树的对应节点的编号相同。\n>\n> 1. 给定一颗满二叉树,由根节点逐层从左至右标号,在满二叉树的基础上,删去标号最高的节点,即为完全二叉树\n> 2. 在完全二叉树的基础上,再删去标号最高的节点,也可以得到一颗完全二叉树\n>\n> 故由概念可知,不完整的层只有一层,且不完整的层只有右边的节点缺失,或是一颗满二叉树的二叉树,是完全二叉树\n\n> **一颗深度为k的完全二叉树,至少拥有多少个节点?  2^(k-1)**\n>\n> **一颗深度为k的完全二叉树,至少拥有多少个叶子节点?  2^(k-2)**\n>\n> |              完全二叉树节点最少问题              |\n> | :----------------------------------------------: |\n> | ![./img/image-20220518212815017](./img/树-1.png) |\n\n#### 1.1.3 二叉树的遍历\n\n[二叉树的遍历demo](https://github.com/seadeemo/algorithm-demo/tree/main/tree-demo/tree-traversal-demo)\n\n> 力扣-树的遍历\n>\n> [力扣-二叉树前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)\n>\n> [力扣-二叉树后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)\n>\n> [力扣-二叉树中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\n>\n> [力扣-N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/)\n>\n> [力扣-N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/)\n\n> 力扣-树的层序遍历\n>\n> [力扣-二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)\n>\n> [力扣-二叉树的层次遍历II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)\n>\n> [力扣-二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)\n>\n> [力扣-二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)\n>\n> [力扣-N叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)\n>\n> [力扣-在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)\n>\n> [力扣-填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)\n>\n> [力扣-填充每个节点的下一个右侧节点指针II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)\n>\n> [力扣-二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)\n>\n> [力扣-二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\n\n##### 1.1.3.1 使用递归遍历：\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * @Description\n * @Author kazusa\n * @Date 2024-03-13 9:30\n */\npublic class ChainedTree<T extends Comparable<T>> {\n\n    private TreeNode<T> root;\n\n    private int size;\n\n    // 中序遍历--递归\n    public List<T> inorderTraversalRecursion() {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n\n        return inorderTraversalRecursion(root);\n    }\n\n    // 中序遍历--递归\n    private List<T> inorderTraversalRecursion(TreeNode<T> currentRoot) {\n        List<T> result = new ArrayList<>();\n        if (currentRoot.left != null) {\n            result.addAll(inorderTraversalRecursion(currentRoot.left));\n        }\n        result.add(currentRoot.val);\n        if (currentRoot.right != null) {\n            result.addAll(inorderTraversalRecursion(currentRoot.right));\n        }\n        return result;\n    }\n\n    // 前序遍历--递归\n    public List<T> preorderTraversalRecursion() {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n\n        return preorderTraversalRecursion(root);\n    }\n\n    // 前序遍历--递归\n    private List<T> preorderTraversalRecursion(TreeNode<T> currentRoot) {\n        List<T> result = new ArrayList<>();\n        result.add(currentRoot.val);\n        if (currentRoot.left != null) {\n            result.addAll(preorderTraversalRecursion(currentRoot.left));\n        }\n        if (currentRoot.right != null) {\n            result.addAll(preorderTraversalRecursion(currentRoot.right));\n        }\n        return result;\n    }\n\n    // 后序遍历--递归\n    public List<T> postorderTraversalRecursion() {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n\n        return postorderTraversalRecursion(root);\n    }\n\n    // 后序遍历--递归\n    private List<T> postorderTraversalRecursion(TreeNode<T> currentRoot) {\n        List<T> result = new ArrayList<>();\n        if (currentRoot.left != null) {\n            result.addAll(postorderTraversalRecursion(currentRoot.left));\n        }\n        if (currentRoot.right != null) {\n            result.addAll(postorderTraversalRecursion(currentRoot.right));\n        }\n        result.add(currentRoot.val);\n        return result;\n    }\n\n    public void insert(T value) {\n        size++;\n        if (root == null) {\n            root = new TreeNode<>();\n            root.val = value;\n            return;\n        }\n        TreeNode<T> current = root;\n        while (true) {\n            if (value.compareTo(current.val) < 0) {\n                if (current.left != null) {\n                    current = current.left;\n                } else {\n                    current.left = new TreeNode<>();\n                    current.left.val = value;\n                    break;\n                }\n            } else {\n                if (current.right != null) {\n                    current = current.right;\n                } else {\n                    current.right = new TreeNode<>();\n                    current.right.val = value;\n                    break;\n                }\n            }\n        }\n    }\n\n\n    private static class TreeNode<T> {\n        private T val;\n\n        private TreeNode<T> left;\n\n        private TreeNode<T> right;\n    }\n\n}\n```\n\n##### 1.1.3.2 使用迭代遍历：\n\n该迭代遍历前、中、后序的写法不统一\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Stack;\n\n/**\n * @Description\n * @Author kazusa\n * @Date 2024-03-13 9:30\n */\npublic class ChainedTree<T extends Comparable<T>> {\n\n    private TreeNode<T> root;\n\n    private int size;\n\n    // 前序遍历--迭代(根左右，栈先进后出，故先右后左，入栈顺序与遍历顺序对应)\n    public List<T> preorderTraversalIteration() {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n        Stack<TreeNode<T>> stack = new Stack<>();\n        TreeNode<T> current;\n        stack.push(root);\n        List<T> result = new ArrayList<>(size);\n        while (!stack.isEmpty()) {\n            current = stack.pop();\n            result.add(current.val);\n            if (current.right != null) {\n                stack.push(current.right);\n            }\n            if (current.left != null) {\n                stack.push(current.left);\n            }\n        }\n        return result;\n    }\n\n    // 中序遍历--迭代(左根右，先找到最左边的，再找右边的，栈仅用作记录入栈关系)\n    public List<T> inorderTraversalIteration() {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n        Stack<TreeNode<T>> stack = new Stack<>();\n        TreeNode<T> current = root;\n        List<T> result = new ArrayList<>(size);\n        while (current != null || !stack.isEmpty()) {\n            if (current != null) {\n                stack.push(current);\n                current = current.left;\n            } else {\n                current = stack.pop();\n                result.add(current.val);\n                current = current.right;\n            }\n        }\n        return result;\n    }\n\n    // 后序遍历--迭代(左右根，实际上是根右左的反向)\n    public List<T> postorderTraversalIteration() {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n        Stack<TreeNode<T>> stack = new Stack<>();\n        stack.push(root);\n        TreeNode<T> current;\n        List<T> result = new ArrayList<>(size);\n        while (!stack.isEmpty()) {\n            current = stack.pop();\n            result.add(current.val);\n            if (current.left != null) {\n                stack.push(current.left);\n            }\n            if (current.right != null) {\n                stack.push(current.right);\n            }\n        }\n        Collections.reverse(result);\n        return result;\n    }\n\n    public void insert(T value) {\n        size++;\n        if (root == null) {\n            root = new TreeNode<>();\n            root.val = value;\n            return;\n        }\n        TreeNode<T> current = root;\n        while (true) {\n            if (value.compareTo(current.val) < 0) {\n                if (current.left != null) {\n                    current = current.left;\n                } else {\n                    current.left = new TreeNode<>();\n                    current.left.val = value;\n                    break;\n                }\n            } else {\n                if (current.right != null) {\n                    current = current.right;\n                } else {\n                    current.right = new TreeNode<>();\n                    current.right.val = value;\n                    break;\n                }\n            }\n        }\n    }\n\n\n    private static class TreeNode<T> {\n        private T val;\n\n        private TreeNode<T> left;\n\n        private TreeNode<T> right;\n    }\n\n}\n```\n\n##### 1.1.3.3 使用统一写法的迭代遍历(使用null做标记)\n\n```java\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Stack;\n\n/**\n * @Description\n * @Author kazusa\n * @Date 2024-03-13 9:30\n */\npublic class ChainedTree<T extends Comparable<T>> {\n\n    private TreeNode<T> root;\n\n    private int size;\n\n    // 中序遍历--迭代(统一写法)\n    public List<T> inorderTraversal() {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n        Stack<TreeNode<T>> stack = new Stack<>();\n        List<T> result = new ArrayList<>(size);\n        stack.push(root);\n        TreeNode<T> current;\n        while (!stack.isEmpty()) {\n            current = stack.peek();\n            stack.pop();\n            if (current != null) {\n                if (current.right != null) {\n                    stack.push(current.right);\n                }\n                stack.push(current);\n                stack.push(null);\n                if (current.left != null) {\n                    stack.push(current.left);\n                }\n            } else {\n                current = stack.pop();\n                result.add(current.val);\n            }\n        }\n        return result;\n    }\n\n    // 前序遍历--迭代(统一写法)\n    public List<T> preorderTraversal() {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n        Stack<TreeNode<T>> stack = new Stack<>();\n        List<T> result = new ArrayList<>(size);\n        stack.push(root);\n        TreeNode<T> current;\n        while (!stack.isEmpty()) {\n            current = stack.peek();\n            stack.pop();\n            if (current != null) {\n                if (current.right != null) {\n                    stack.push(current.right);\n                }\n                if (current.left != null) {\n                    stack.push(current.left);\n                }\n                stack.push(current);\n                stack.push(null);\n            } else {\n                current = stack.pop();\n                result.add(current.val);\n            }\n        }\n        return result;\n    }\n\n    // 后序遍历--迭代(统一写法)\n    public List<T> postorderTraversal() {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n        Stack<TreeNode<T>> stack = new Stack<>();\n        List<T> result = new ArrayList<>(size);\n        stack.push(root);\n        TreeNode<T> current;\n        while (!stack.isEmpty()) {\n            current = stack.peek();\n            stack.pop();\n            if (current != null) {\n                stack.push(current);\n                stack.push(null);\n                if (current.right != null) {\n                    stack.push(current.right);\n                }\n                if (current.left != null) {\n                    stack.push(current.left);\n                }\n            } else {\n                current = stack.pop();\n                result.add(current.val);\n            }\n        }\n        return result;\n    }\n\n    public void insert(T value) {\n        size++;\n        if (root == null) {\n            root = new TreeNode<>();\n            root.val = value;\n            return;\n        }\n        TreeNode<T> current = root;\n        while (true) {\n            if (value.compareTo(current.val) < 0) {\n                if (current.left != null) {\n                    current = current.left;\n                } else {\n                    current.left = new TreeNode<>();\n                    current.left.val = value;\n                    break;\n                }\n            } else {\n                if (current.right != null) {\n                    current = current.right;\n                } else {\n                    current.right = new TreeNode<>();\n                    current.right.val = value;\n                    break;\n                }\n            }\n        }\n    }\n\n    private static class TreeNode<T> {\n        private T val;\n\n        private TreeNode<T> left;\n\n        private TreeNode<T> right;\n    }\n\n}\n```\n\n##### 1.1.3.4 层序遍历\n\n```java\n/**\n * @Description\n * @Author kazusa\n * @Date 2024-03-13 9:30\n */\npublic class ChainedTree<T extends Comparable<T>> {\n\n    private TreeNode<T> root;\n\n    private int size;\n\n    // 层序遍历\n    public List<List<T>> levelOrder() {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n\n        Queue<TreeNode<T>> queue = new LinkedList<>();\n        List<List<T>> result = new LinkedList<>();\n        queue.offer(root);\n        TreeNode<T> current;\n        while (!queue.isEmpty()) {\n            List<T> currentList = new LinkedList<>();\n            int size = queue.size();\n            while (size > 0) {\n                current = queue.poll();\n                if (current.left != null) {\n                    queue.offer(current.left);\n                }\n                if (current.right != null) {\n                    queue.offer(current.right);\n                }\n                currentList.add(current.val);\n                size--;\n            }\n            result.add(currentList);\n        }\n        return result;\n    }\n\n    public void insert(T value) {\n        size++;\n        if (root == null) {\n            root = new TreeNode<>();\n            root.val = value;\n            return;\n        }\n        TreeNode<T> current = root;\n        while (true) {\n            if (value.compareTo(current.val) < 0) {\n                if (current.left != null) {\n                    current = current.left;\n                } else {\n                    current.left = new TreeNode<>();\n                    current.left.val = value;\n                    break;\n                }\n            } else {\n                if (current.right != null) {\n                    current = current.right;\n                } else {\n                    current.right = new TreeNode<>();\n                    current.right.val = value;\n                    break;\n                }\n            }\n        }\n    }\n\n    private static class TreeNode<T> {\n        private T val;\n\n        private TreeNode<T> left;\n\n        private TreeNode<T> right;\n    }\n\n}\n```\n\n### 1.2 2-3-4树\n\n> 2-3-4树是一种多路查找树\n>\n> 1. 所有叶子节点拥有相同的深度\n> 2. 节点只能是2节点(一个元素,最多有两个子节点),3节点(两个元素,最多有三个子节点),4节点(三个元素,最多有四个子节点)\n> 3. 所有节点至少包含一个元素\n>\n> |                 2-3-4树添加元素                  |\n> | :----------------------------------------------: |\n> | ![./img/image-20220519142946533](./img/树-2.png) |\n>\n> |                   2-3-4树节点                    |\n> | :----------------------------------------------: |\n> | ![./img/image-20220519142513669](./img/树-3.png) |\n\n### 1.3 红黑树\n\n#### 1.3.1 红黑树定义\n\n> 红黑树:\n>\n> 1. 每个节点要么是黑色,要么是红色\n> 2. 根节点是黑色\n> 3. 每个叶子节点是NIL节点(空值节点),是黑色节点\n> 4. 不存在两个连续的红节点\n> 5. 任意一个节点到每一个叶子节点的路径上,包含相同数量的黑节点<font color=\"red\">(其实统计的是2-3-4树中的层数,黑节点是用来标记曾在2-3-4树中的层级,故红黑树的平衡指的是黑节点的平衡)</font>\n\n#### 1.3.2 2-3-4树转红黑树\n\n> 2-3-4树转化为红黑树:\n>\n> 1. 2节点 ----> 黑节点\n> 2. 3节点 ----> 一黑一红\n> 3. 4节点 ----> 一黑两红\n>\n> |                2-3-4树转化红黑树                 |\n> | :----------------------------------------------: |\n> | ![./img/image-20220519144513388](./img/树-4.png) |\n\n#### 1.3.3 红黑树插入元素\n\n> <font color=\"red\">红黑树插入元素时注意! 需要插入到红黑节点之间或之后时,需要考虑自平衡的状态!</font>\n>\n> | 向下图中的红黑树中插入值为3.1的节点,插入之后的红黑树应该是怎么样? |\n> | :----------------------------------------------------------: |\n> |   ![./img/image-20220519150430936](./img/树-5.png)   |\n>\n> ![./img/image-20220519150923506](./img/树-6.png)\n>\n> |              向如下图左树中插入2.5               |\n> | :----------------------------------------------: |\n> | ![./img/image-20220519154901776](./img/树-7.png) |\n","tags":["算法","数据结构","树"],"categories":["算法","数据结构"]},{"title":"easyexcel自定义excel导出","url":"/2024/03/11/EasyExcel实现非模板自定义Excel导出/","content":"\n### 1 关于需求\n\n最近需要做一个Excel的动态导出，大致样式如下：\n\n![image-20240311093225548](/img/EasyExcel实现非模板自定义Excel导出-1.png)\n\n我们可以根据需求将一个excel分为如下图的四个部分：\n\n![企业微信截图_17101209325397](/img/EasyExcel实现非模板自定义Excel导出-4.png)\n\n图中的excel大致可以分为四个部分：\n\n\t1. 标题部分，最关键的地方就在于需要动态的根据导出的总列数来合并单元格\n\t1. 单据数据部分，这一部分是整个单据的基础信息，需要水平方向排列，并且需要支持仅导出特定的字段\n\t1. 货品数据部分，这一部分就是最常见的excel表格的排列方式了，只是也需要支持仅导出特定字段\n\t1. 签字栏，这部分和单据数据部分相似，都是水平方向排列\n\n选择使用easyexcel来实现该功能。\n\n### 2 版本信息\n\neasyexcel使用2.2.10，cglib使用3.1\n\n```xml\n<dependency>\n\t<groupId>com.alibaba</groupId>\n\t<artifactId>easyexcel</artifactId>\n\t<version>2.2.10</version>\n\t<exclusions>\n\t\t<exclusion>\n\t\t\t<groupId>cglib</groupId>\n\t\t\t<artifactId>cglib</artifactId>\n\t\t</exclusion>\n\t</exclusions>\n</dependency>\n<dependency>\n\t<groupId>cglib</groupId>\n\t<artifactId>cglib</artifactId>\n\t<version>3.1</version>\n</dependency>\n```\n\n其他依赖如下\n\n```xml\n<dependency>\n\t<groupId>org.projectlombok</groupId>\n\t<artifactId>lombok</artifactId>\n</dependency>\n<dependency>\n\t<groupId>cn.hutool</groupId>\n\t<artifactId>hutool-all</artifactId>\n\t<version>5.8.25</version>\n</dependency>\n```\n\n### 3 基本实现\n\n对于标题、单据数据、签字栏部分，可以使用List<List\\<String>>的数据来实现；而货品数据部分，直接使用List\\<Object>的方式更加方便。\n\n货品数据的实体类如下：\n\n```java\nimport com.alibaba.excel.annotation.ExcelProperty;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\n\nimport java.math.BigDecimal;\n\n/**\n * @Description 基本的例子\n * @Author kazusa\n * @Date 2024-03-08 17:04\n */\n@Data\n@AllArgsConstructor\npublic class SimpleDomain {\n\n    @ExcelProperty(\"ID\")\n    private Long id;\n\n    @ExcelProperty(\"姓名\")\n    private String name;\n\n    @ExcelProperty(\"年龄\")\n    private Integer age;\n\n    @ExcelProperty(\"银行余额\")\n    private BigDecimal bankBalance;\n\n    @ExcelProperty(\"描述\")\n    private String desc;\n\n    @ExcelProperty(\"不导出的属性\")\n    private String exclude;\n\n}\n```\n\n导出工具类如下：\n\n```java\nimport com.alibaba.excel.EasyExcel;\nimport com.alibaba.excel.ExcelWriter;\nimport com.alibaba.excel.support.ExcelTypeEnum;\nimport com.alibaba.excel.write.merge.OnceAbsoluteMergeStrategy;\nimport com.alibaba.excel.write.metadata.WriteSheet;\nimport com.alibaba.excel.write.metadata.WriteTable;\nimport com.kazusa.test.easyexcel.demo.simple.domain.SimpleDomain;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * @Description 基本的例子\n * @Author kazusa\n * @Date 2024-03-08 17:07\n */\npublic class SimpleTestService {\n\n    private static final String FILE_LOCATION = \"D:/test.xlsx\";\n\n    public void export() {\n        // 构建writer\n        ExcelWriter writer = EasyExcel.write(FILE_LOCATION, SimpleDomain.class)\n                .autoCloseStream(Boolean.FALSE)\n                .excelType(ExcelTypeEnum.XLSX)\n                .needHead(Boolean.TRUE)\n                .build();\n\n        // 构建sheet\n        WriteSheet sheet = EasyExcel.writerSheet(\"test-sheet-name\")\n                .needHead(Boolean.FALSE)\n                .build();\n\n        // 构建标题\n        List<List<String>> title = Collections.singletonList(Collections.singletonList(\"标题1\"));\n        WriteTable titleTable = EasyExcel.writerTable(0)\n                .needHead(Boolean.FALSE)\n                .registerWriteHandler(new OnceAbsoluteMergeStrategy(0, 0, 0, 7))// 合并单元格\n                .build();\n        // 写入标题\n        writer.write(title, sheet, titleTable);\n\n        // 构建两个表的数据：一个竖直方向排列，一个水平方向排列\n        String blank = \"     \";\n        List<List<String>> vTableData = Arrays.asList(\n                Arrays.asList(\"编号:\", \"4536251\", blank, \"时间:\", \"2024-01-02\", blank, \"操作人:\", \"ADMIN\"),\n                Arrays.asList(\"操作时间:\", \"2024-01-01\"),\n                Arrays.asList(\"描述信息:\", \"描述描述描述描述描述描述描述描述\"),\n                Collections.singletonList(\"\") // 添加一个空行\n        );\n\n        List<SimpleDomain> hTableData = Arrays.asList(\n                new SimpleDomain(1L, \"张三\", 24, new BigDecimal(\"22.22\"), \"张三的描述很短\", \"不导出\"),\n                new SimpleDomain(2L, \"李四\", 30, new BigDecimal(\"22222.22\"), \"李四的描述很短\", \"不导出\"),\n                new SimpleDomain(3L, \"王五\", 56, new BigDecimal(\"22333.22\"), \"王五的描述很短\", \"不导出\"),\n                new SimpleDomain(4L, \"赵六\", 16, new BigDecimal(\"22.2244\"), \"赵六的描述很短\", \"不导出\"),\n                new SimpleDomain(5L, \"钱七\", 23, BigDecimal.ZERO, \"钱七的描述很短才怪钱七的描述很短才怪钱七的描述很短才怪钱七的描述很短才怪钱七的描述很短才怪钱七的描述很短才怪\", \"不导出\")\n        );\n\n        // 写入两个表：一个竖直方向排列，一个水平方向排列\n        WriteTable vTable = EasyExcel.writerTable(1).build();\n        writer.write(vTableData, sheet, vTable);\n\n        WriteTable hTable = EasyExcel.writerTable(2)// 需要指定tableNo,head才能正常导出\n                .includeColumnFiledNames(Arrays.asList(\"id\", \"name\", \"age\", \"bankBalance\", \"desc\"))// 选择某些属性导出\n//                .excludeColumnFiledNames()// 也可以排除某些属性\n                .needHead(Boolean.TRUE)\n                .build();\n        writer.write(hTableData, sheet, hTable);\n\n        writer.finish();\n    }\n\n    public static void main(String[] args) {\n        new SimpleTestService().export();\n    }\n\n}\n```\n\n最终导出结果如图：\n\n![image-20240311095425156](/img/EasyExcel实现非模板自定义Excel导出-2.png)\n\n可以看到，基本实现了我们的需求，但是有一个问题：列宽并没有自适应，导致部分列的文本显示不全。我们在26行和38行添加自适应列宽的handler，代码如下：\n\n```java\nimport com.alibaba.excel.EasyExcel;\nimport com.alibaba.excel.ExcelWriter;\nimport com.alibaba.excel.support.ExcelTypeEnum;\nimport com.alibaba.excel.write.handler.WriteHandler;\nimport com.alibaba.excel.write.merge.OnceAbsoluteMergeStrategy;\nimport com.alibaba.excel.write.metadata.WriteSheet;\nimport com.alibaba.excel.write.metadata.WriteTable;\nimport com.alibaba.excel.write.style.column.LongestMatchColumnWidthStyleStrategy;\nimport com.kazusa.test.easyexcel.demo.simple.domain.SimpleDomain;\n\nimport java.math.BigDecimal;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * @Description 基本的例子\n * @Author kazusa\n * @Date 2024-03-08 17:07\n */\npublic class SimpleTestService {\n\n    private static final String FILE_LOCATION = \"D:/test.xlsx\";\n\n    public void export() {\n        // 构建一个自动列宽handler\n        WriteHandler autoResize = new LongestMatchColumnWidthStyleStrategy();\n\n        // 构建writer\n        ExcelWriter writer = EasyExcel.write(FILE_LOCATION, SimpleDomain.class)\n                .autoCloseStream(Boolean.FALSE)\n                .excelType(ExcelTypeEnum.XLSX)\n                .needHead(Boolean.TRUE)\n                .build();\n\n        // 构建sheet\n        WriteSheet sheet = EasyExcel.writerSheet(\"test-sheet-name\")\n                .registerWriteHandler(autoResize)// 每一个sheet使用一个handler\n                .needHead(Boolean.FALSE)\n                .build();\n\n        // 构建标题\n        List<List<String>> title = Collections.singletonList(Collections.singletonList(\"标题1\"));\n        WriteTable titleTable = EasyExcel.writerTable(0)\n                .needHead(Boolean.FALSE)\n                .registerWriteHandler(new OnceAbsoluteMergeStrategy(0, 0, 0, 7))// 合并单元格\n                .build();\n        // 写入标题\n        writer.write(title, sheet, titleTable);\n\n        // 构建两个表的数据：一个竖直方向排列，一个水平方向排列\n        String blank = \"     \";\n        List<List<String>> vTableData = Arrays.asList(\n                Arrays.asList(\"编号:\", \"4536251\", blank, \"时间:\", \"2024-01-02\", blank, \"操作人:\", \"ADMIN\"),\n                Arrays.asList(\"操作时间:\", \"2024-01-01\"),\n                Arrays.asList(\"描述信息:\", \"描述描述描述描述描述描述描述描述\"),\n                Collections.singletonList(\"\") // 添加一个空行\n        );\n\n        List<SimpleDomain> hTableData = Arrays.asList(\n                new SimpleDomain(1L, \"张三\", 24, new BigDecimal(\"22.22\"), \"张三的描述很短\", \"不导出\"),\n                new SimpleDomain(2L, \"李四\", 30, new BigDecimal(\"22222.22\"), \"李四的描述很短\", \"不导出\"),\n                new SimpleDomain(3L, \"王五\", 56, new BigDecimal(\"22333.22\"), \"王五的描述很短\", \"不导出\"),\n                new SimpleDomain(4L, \"赵六\", 16, new BigDecimal(\"22.2244\"), \"赵六的描述很短\", \"不导出\"),\n                new SimpleDomain(5L, \"钱七\", 23, BigDecimal.ZERO, \"钱七的描述很短才怪钱七的描述很短才怪钱七的描述很短才怪钱七的描述很短才怪钱七的描述很短才怪钱七的描述很短才怪\", \"不导出\")\n        );\n\n        // 写入两个表：一个竖直方向排列，一个水平方向排列\n        WriteTable vTable = EasyExcel.writerTable(1).build();\n        writer.write(vTableData, sheet, vTable);\n\n        WriteTable hTable = EasyExcel.writerTable(2)// 需要指定tableNo,head才能正常导出\n                .includeColumnFiledNames(Arrays.asList(\"id\", \"name\", \"age\", \"bankBalance\", \"desc\"))// 选择某些属性导出\n//                .excludeColumnFiledNames()// 也可以排除某些属性\n                .needHead(Boolean.TRUE)\n                .build();\n        writer.write(hTableData, sheet, hTable);\n\n        writer.finish();\n    }\n\n    public static void main(String[] args) {\n        new SimpleTestService().export();\n    }\n\n}\n```\n\n最后导出结果如下：\n\n![image-20240311095937208](/img/EasyExcel实现非模板自定义Excel导出-3.png)\n\n基本实现样式需求，剩余的文本居中、字体大小、单元格背景等easyexcel均提供了比较简单的api。\n\n### 4 完全实现\n\n详见：https://github.com/seadeemo/spring-demo/tree/main/easyexcel-demo\n\n其中实现了单个excel单个sheet、单个excel多sheet、多个excel压缩包导出。\n\n","tags":["Java","Excel"],"categories":["实用"]}]