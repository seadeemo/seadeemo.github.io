[{"title":"test-blog-with-pic","url":"/2024/03/01/test-blog-with-pic/","content":"\n添加说明\n\n<!-- more -->\n\n### 1 需求背景\n\n最近公司需要做一个动态字段的Excel导出，大致的样式如下：\n\n![Excel示例](image-20230606104726048.png)\n\n实体类如下：\n\n```java\n// 部门实体类\npublic class Department {\n    private String companyName;\n    private String name;\n    private String fullName;\n    private String leaderName;\n    private String business;\n    private Long count;\n    private String location;\n    private String status;\n    private List<Staff> staffList;\n}\n//员工实体类\npublic class Staff {\n    private Long id;\n    private String name;\n    private Long age;\n    private String position;\n    private BigDecimal salary;\n    private String code;\n}\n```\n\n具体要求如下：\n\n1. 标题部分需要合并单元格；\n2. 展示部门信息的表格需要横向展示数据，且用户可以选择导出哪些字段的数据；\n3. 展示员工信息部分的数据为一个表格，用户可以选择导出哪些字段的数据。\n\n如图所示，Excel可以被分成三个部分：\n\n![Excel分类实例](企业微信截图_16860187599012.png)\n\n这三个部分都需要动态生成，理由如下：\n\n\t\t1. 标题部分需要展示公司信息以及导出的是什么Excel（例如销售单、物流单等等），后续可能需要展示更多的信息，也就是说行数是动态的。并且图中的第三个部分也就是列表数据部分字段的个数是动态的，也就是说标题部分的列数也是动态的；\n\t\t1. 公共部分同理，且公共部分的字段也需要可选择的导出；\n\t\t1. 列表数据部分的字段个数以及数据的条数都是动态的，那么行和列都是动态的；\n\n综上，我们现在的问题如下：\n\n1. 三个部分的表格行、列都是动态的；\n2. 三个部分在一个Excel中导出，列宽都会互相影响，如何自适应列宽？\n3. 公共部分的表格并不是传统的竖向表格，是横向排列的。\n4. 如何对应字段名和在Excel中显示的字段名的关系？比如某个字段在代码中为`name`，但Excel中应该显示为`姓名`。\n5. 如何确定字段之间在Excel导出时的顺序，譬如`name` `age` `salary`三个字段，我希望它们按照name-age-salary的顺序显示，如果用户只导出name和salary字段，那顺序也应该是name-salary而不是其他的。\n\n### 2 抽象导出实体类\n\n如之前所说，可以将Excel分为三个部分，那么此时就可以构建一个类用以支持Excel的动态导出，具体代码如下：\n\n```java\n// Excel实体类\npublic class ExportCustomCommon {\n    // 标题部分，应该有几行就有几条\n    List<String> headerTable;\n    // 公共部分\n    ExcelCommonData commonTable;\n    // 列表数据部分\n    List<? extends ExcelListData> listTable;\n    \n   \t // 列表数据的实体类，没有任何属性，仅作为一个对象的静态类型，方便统一处理\n\tpublic static class ExcelListData{}\n\n    // 公共数据的实体类，没有任何属性，仅作为一个对象的静态类型，方便统一处理\n\tpublic static class ExcelCommonData{}\n}\n```\n\n### 3 EasyExcel实现\n\n引入EasyExcel依赖，我在这里使用的版本是2.2.10 。\n\n```xml\n<dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>easyexcel</artifactId>\n    \t<version>2.2.10</version>\n</dependency>\n```\n\n首先需要知道，EasyExcel中有一个@ExcelProperty的注解，代码如下：\n\n```java\npackage com.alibaba.excel.annotation;\nimport ......\npublic @interface ExcelProperty {\n\t// 显示在Excel中的字段名\n    String[] value() default {\"\"};\n\n\t// 排序，值越小，优先级越高\n    int order() default Integer.MAX_VALUE;\n…………\n}\n```\n\n其余还有一些属性，但在本案例中没有用到，就不多做介绍。如此，字段在Excel中展示的名称问题和字段排序的问题通过EasyExcel自带的注解就已经可以解决。\n\n接下来就是将需要导出的实体类加上注解：\n\n```java\npublic class DepartmentExcel extends ExportCustomCommon.ExcelCommonData {\n    @ExcelProperty(value = \"公司名\", order = 1)\n    private String companyName;\n    @ExcelProperty(value = \"部门名\", order = 2)\n    private String name;\n    @ExcelProperty(value = \"部门全名\", order = 3)\n    private String fullName;\n    @ExcelProperty(value = \"部门领导名\", order = 4)\n    private String leaderName;\n    @ExcelProperty(value = \"业务类型\", order = 5)\n    private String business;\n    @ExcelProperty(value = \"人数\", order = 6)\n    private Long count;\n    @ExcelProperty(value = \"地址\", order = 7)\n    private String location;\n    @ExcelProperty(value = \"状态\", order = 8)\n    private String status;\n}\n```\n\n```java\npublic class StaffExcel extends ExportCustomCommon.ExcelListData {\n    private Long id;\n    @ExcelProperty(value = \"姓名\", order = 1)\n    private String name;\n    @ExcelProperty(value = \"年龄\", order = 2)\n    private Long age;\n    @ExcelProperty(value = \"职位\", order = 3)\n    private String position;\n    @ExcelProperty(value = \"工资\", order = 4)\n    private BigDecimal salary;\n    @ExcelProperty(value = \"编码\", order = 5)\n    private String code;\n}\n```\n\n需要注意：Department中的数据用于公共部分表格，所以需要继承ExcelCommonData；Staff中数据是列表数据的展示，所以继承ExcelListData。\n\n接下来是数据的获取及导出，标题部分很好解决，有几条数据就写几行，然后合并单元格就行了；列表数据部分也好解决，只需要使用EasyExcel自带的动态导出即可；关键是公共部分，因为是横向排列，并且列数不定，所以需要我们自己来做实现，具体代码如下：\n\n```java\npackage com.kazusa.excel.demo;\n\nimport cn.hutool.core.lang.Assert;\nimport cn.hutool.core.util.ObjectUtil;\nimport com.alibaba.excel.EasyExcel;\nimport com.alibaba.excel.ExcelWriter;\nimport com.alibaba.excel.annotation.ExcelProperty;\nimport com.alibaba.excel.support.ExcelTypeEnum;\nimport com.alibaba.excel.write.merge.OnceAbsoluteMergeStrategy;\nimport com.alibaba.excel.write.metadata.WriteSheet;\nimport com.alibaba.excel.write.metadata.WriteTable;\nimport com.alibaba.excel.write.metadata.style.WriteCellStyle;\nimport com.alibaba.excel.write.metadata.style.WriteFont;\nimport com.alibaba.excel.write.style.HorizontalCellStyleStrategy;\nimport com.alibaba.excel.write.style.column.LongestMatchColumnWidthStyleStrategy;\nimport org.apache.poi.ss.usermodel.BorderStyle;\nimport org.apache.poi.ss.usermodel.HorizontalAlignment;\nimport org.apache.poi.ss.usermodel.IndexedColors;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.Collectors;\n\n/**\n * @Description EasyExcel导出工具类\n * @Author Kazusa\n */\npublic class EasyExcelUtil {\n\n    public void export(OutputStream os, Map<String, Object> params, List<String> fields) {\n        //获取标题部分数据\n        List<String> headerTable = (List) params.get(\"headerTable\");\n        //获取公共部分数据\n        ExportCustomCommon.ExcelCommonData commonTable = (ExportCustomCommon.ExcelCommonData) params.get(\"commonTable\");\n        //获取列表部分数据\n        List<ExportCustomCommon.ExcelListData> listTable = (List) params.get(\"listTable\");\n        //获取列表部分数据的类对象\n        Class<? extends ExportCustomCommon.ExcelListData> listDataClass = listTable.get(0).getClass();\n        //构建EasyExcel Writer对象\n        ExcelWriter writer = null;\n\n        try {\n            writer = EasyExcel.write(os, listDataClass)//指定写入的流，以及需要EasyExcel自带动态生成的类的类对象\n                    .excelType(ExcelTypeEnum.XLSX)//指定Excel文件类型，如xlsx、xls等\n                \t.build();\n            WriteSheet sheet = EasyExcel\n                    .writerSheet(\"sheet1\")//指定写入的sheet\n                    .needHead(false)//是否需要head，也就是每一个字段对应的字段名，这里为不需要，我们需要EasyExcel去生成字段名的地方只有列表数据部分\n                    .build();\n            //使用一个计数器记录当前已经写了几个表格\n            AtomicInteger tableNoCounting = new AtomicInteger(1);\n            //需要知道列数的最大值是多少\n            int maxColumn = fields.size();\n            this.buildHeader(maxColumn, headerTable, sheet, writer, tableNoCounting);\n            this.buildCommon(maxColumn, commonTable, sheet, writer, tableNoCounting);\n            this.buildList(listTable, sheet, writer, tableNoCounting, fields);\n        } finally {\n            assert writer != null;\n            // 关闭流\n            writer.finish();\n        }\n\n    }\n\n    /**\n     * 构建标题\n     */\n    private void buildHeader(int maxColumn, List<String> headerList, WriteSheet sheet, ExcelWriter writer, AtomicInteger tableNoCounting) {\n        //自定义到处样式\n        WriteCellStyle cellStyle = new WriteCellStyle();\n        //水平居中\n        cellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);\n        WriteFont writeFont = new WriteFont();\n        //加粗\n        writeFont.setBold(Boolean.TRUE);\n        //字体大小\n        writeFont.setFontHeightInPoints((short) 15);\n        cellStyle.setWriteFont(writeFont);\n        //遍历标题部分的List\n        for (String header : headerList) {\n            WriteTable table = EasyExcel\n                    .writerTable(tableNoCounting.get())//指定写入表格的序号，EasyExcel会将多个表格按照序号从小到大、由上到下的排列\n                    .needHead(Boolean.FALSE)//也不需要标题\n                    .registerWriteHandler(\n                            //合并标题的单元格\n                            new OnceAbsoluteMergeStrategy(tableNoCounting.get() - 1, tableNoCounting.getAndIncrement() - 1, 0, maxColumn)\n                    )\n                    //将自定义样式应用与该表\n                    .registerWriteHandler(new HorizontalCellStyleStrategy(cellStyle, cellStyle))\n                    .build();\n            //在这里，由于EasyExcel使用List<List<String>>这样的数据来构建一个表，里面的List<String>表示一行数据。\n            //所以我们这里一次只构建一行数据，一行数据中只有一个单元格的数据，一行数据就作为一个表格写入\n            //故有几个标题就需要构建几次表格\n            List<String> cellList = new ArrayList<>();\n            cellList.add(header);\n            //因为需要合并单元格到列数最大的单元格处，这里如果不添加空字符串，EasyExcel不会构建单元格，在合并单元格的时候就会报错\n            for (int i = 0; i < maxColumn - 1; ++i) {\n                cellList.add(\"\");\n            }\n            List<List<String>> rowList = new ArrayList<>();\n            rowList.add(cellList);\n            //写入表格\n            writer.write(rowList, sheet, table);\n        }\n    }\n\n    /**\n     * 属性实体类\n     */\n    private static class ExcelField {\n        //属性名\n        private String fieldName;\n        //Excel中显示名\n        private String showName;\n        //排序\n        private int order;\n        //属性值\n        private Object value;\n\n        public String getFieldName() {\n            return fieldName;\n        }\n\n        public void setFieldName(String fieldName) {\n            this.fieldName = fieldName;\n        }\n\n        public String getShowName() {\n            return showName;\n        }\n\n        public void setShowName(String showName) {\n            this.showName = showName;\n        }\n\n        public int getOrder() {\n            return order;\n        }\n\n        public void setOrder(int order) {\n            this.order = order;\n        }\n\n        public Object getValue() {\n            return value;\n        }\n\n        public void setValue(Object value) {\n            this.value = value;\n        }\n    }\n\n    /**\n     * 构建公共部分\n     */\n    private void buildCommon(int maxColumn, ExportCustomCommon.ExcelCommonData commonTable, WriteSheet sheet, ExcelWriter writer, AtomicInteger tableNoCounting) {\n        if (ObjectUtil.isNotEmpty(commonTable)) {\n            //获取公共数据的类对象\n            Class<?> commonDataClass = commonTable.getClass();\n            //通过类对象获取该类中的所有属性\n            List<Field> fields = this.getAllField(commonDataClass);\n            List<ExcelField> fieldList = new ArrayList<>();\n            try {\n                for (Field field : fields) {\n                    //如果在Maven打包时报错，Spring项目中可以替换为Spring中的BeanUtils.getPropertyDescriptor（）\n                    PropertyDescriptor pd = new PropertyDescriptor(field.getName(), commonDataClass);\n                    Assert.notNull(pd, Exception::new);\n                    //反射获取读方法\n                    Method readMethod = pd.getReadMethod();\n                    //读到属性值\n                    Object fieldValue = readMethod.invoke(commonTable);\n                    //获取属性注解\n                    ExcelProperty property = field.getAnnotation(ExcelProperty.class);\n                    //获取Excel显示名称\n                    String excelFieldName = property.value()[0];\n                    //获取Excel中排序\n                    int excelFieldOrder = property.order();\n                    //构建对象\n                    ExcelField excelField = new ExcelField();\n                    excelField.setFieldName(field.getName());\n                    excelField.setShowName(excelFieldName);\n                    excelField.setOrder(excelFieldOrder);\n                    excelField.setValue(fieldValue);\n                    fieldList.add(excelField);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n            //根据Order排序\n            fieldList.sort(Comparator.comparingInt(ExcelField::getOrder));\n            int count = fieldList.size();\n            //计算一行显示属性的个数，除以3是因为一个属性需要属性名--属性值--空字符串三个单元格\n            int lineCount = maxColumn / 3;\n            //计算行数\n            int rows = (count + lineCount - 1) / lineCount;\n            List<Object> cellList = new ArrayList<>();\n            List<List<Object>> rowList = new ArrayList<>();\n            //自定义样式\n            WriteCellStyle cellStyle = new WriteCellStyle();\n            //水平靠左\n            cellStyle.setHorizontalAlignment(HorizontalAlignment.LEFT);\n            //遍历所有行，一行作为一个表\n            for (int row = 0; row < rows; ++row) {\n                WriteTable table = EasyExcel.writerTable(tableNoCounting.getAndIncrement())\n                        .needHead(Boolean.FALSE)\n                        .registerWriteHandler(\n                                new HorizontalCellStyleStrategy(cellStyle, cellStyle)\n                        ).build();\n                //构建List<List<String>>类型的数据给EasyExcel导出\n                for (int i = 0; i < lineCount && row * lineCount + i < count; ++i) {\n                    ExcelField field = fieldList.get(row * lineCount + i);\n                    cellList.add(field.getShowName() + \":\");\n                    cellList.add(field.getValue());\n                    cellList.add(\"\");\n                }\n                \n                rowList.add(cellList);\n                //指定写入的sheet和table\n                writer.write(rowList, sheet, table);\n                cellList.clear();\n                rowList.clear();\n            }\n        }\n    }\n\n    /**\n     * 构建列表部分\n     */\n    private void buildList(List<ExportCustomCommon.ExcelListData> listTable, WriteSheet sheet, ExcelWriter writer, AtomicInteger tableNoCounting, List<String> fields) {\n        //自定义样式\n        WriteCellStyle headStyle = new WriteCellStyle();\n        //设置header背景颜色为透明\n        headStyle.setFillForegroundColor(IndexedColors.AUTOMATIC.getIndex());\n        //水平居中\n        headStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);\n        //上下左右四个边框\n        headStyle.setBorderBottom(BorderStyle.THIN);\n        headStyle.setBorderTop(BorderStyle.THIN);\n        headStyle.setBorderLeft(BorderStyle.THIN);\n        headStyle.setBorderRight(BorderStyle.THIN);\n        WriteFont writeFont = new WriteFont();\n        //字体加粗\n        writeFont.setBold(Boolean.TRUE);\n        //字号\n        writeFont.setFontHeightInPoints((short) 12);\n        headStyle.setWriteFont(writeFont);\n        WriteCellStyle contentStyle = new WriteCellStyle();\n        //内容上下左右四个边框\n        contentStyle.setBorderBottom(BorderStyle.THIN);\n        contentStyle.setBorderTop(BorderStyle.THIN);\n        contentStyle.setBorderLeft(BorderStyle.THIN);\n        contentStyle.setBorderRight(BorderStyle.THIN);\n        //水平居中\n        contentStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);\n        WriteTable table = EasyExcel.writerTable(tableNoCounting.getAndIncrement())\n                .needHead(Boolean.TRUE)//需要Header\n                .registerWriteHandler(new HorizontalCellStyleStrategy(headStyle, contentStyle))//传入自定义样式\n                .includeColumnFiledNames(fields)//选择需要哪些属性\n                .build();\n        writer.write(listTable, sheet, table);\n    }\n\n    //获取该类的所有属性，包括父类中不重名的属性\n    private List<Field> getAllField(Class<?> clazz) {\n        List<Field> resultList = new ArrayList<>();\n        for (List<String> fieldNameList = new ArrayList<>(); \n             clazz != null && !clazz.getName().toLowerCase().equals(ExportCustomCommon.class.getName());\n             clazz = clazz.getSuperclass()) {\n            List<Field> subFields = Arrays.asList(clazz.getDeclaredFields());\n            List<Field> list = subFields.stream()\n                    .filter((f) -> !fieldNameList.contains(f.getName()))\n                    .collect(Collectors.toList());\n            List<String> nameList = list.stream().map(Field::getName).collect(Collectors.toList());\n            resultList.addAll(list);\n            fieldNameList.addAll(nameList);\n        }\n        return resultList;\n    }\n}\n```\n\n接下来构建测试类\n\n```java\npackage com.kazusa.excel.demo;\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\n\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * @Description Excel导出测试类\n * @Author kazusa\n */\npublic class TestMain {\n\n    public static void main(String[] args) throws IOException {\n        EasyExcelUtil excelUtil = new EasyExcelUtil();\n        //构建标题\n        List<String> header = Arrays.asList(\"标题1\", \"标题2\");\n        //构建公共部分\n        DepartmentExcel department = new DepartmentExcel();\n        department.setCompanyName(\"TestCompany\");\n        department.setName(\"Name\");\n        department.setFullName(\"FullName\");\n        department.setLeaderName(\"LeaderName\");\n        department.setBusiness(\"Business\");\n        department.setCount(1000L);\n        department.setLocation(\"Location\");\n        department.setStatus(\"Status\");\n        //构建列表部分\n        List<StaffExcel> staffs = new ArrayList<>();\n        for (int i = 0; i < 10; i++) {\n            StaffExcel staff = new StaffExcel();\n            staff.setId((long) i);\n            staff.setName(\"staff-name\" + i);\n            staff.setAge((long) (i + 20));\n            staff.setPosition(\"position\" + i);\n            staff.setSalary(new BigDecimal(i));\n            staff.setCode(\"code\" + i);\n            staff.setField1(\"field1\" + i);\n            staff.setField2(\"field2\" + i);\n            staff.setField3(\"field3\" + i);\n            staff.setField4(\"field4\" + i);\n            staffs.add(staff);\n        }\n        //构建属性\n        List<String> fieldList = Arrays.asList(\"name\", \"age\", \"position\", \"salary\", \"code\"\n                , \"field1\", \"field2\", \"field3\", \"field4\");\n        ExportCustomCommon common = new ExportCustomCommon();\n        common.setCommonTable(department);\n        common.setHeaderTable(header);\n        common.setListTable(staffs);\n        excelUtil.export(Files.newOutputStream(Paths.get(\"C:\\\\Users\\\\DELL\\\\Desktop\\\\test-excel.xlsx\"))\n                , common, fieldList);\n    }\n}\n```\n\n导出结果如下：\n\n![Excel导出结果-未自适应列宽](image-20230606133919798.png)\n\n可以看到有一些问题，就是我们之前说过的自适应列宽的问题，如果不能根据单元格内文本的长度自适应列宽的话，就会出现某些内容显示不全的问题。万幸EasyExcel已经提供了解决方案，我们在EasyExcelUtil的34、221、272行添加了三行代码使导出的Excel可以自适应列宽。\n\n```java\npackage com.kazusa.excel.demo;\n\nimport cn.hutool.core.lang.Assert;\nimport cn.hutool.core.util.ObjectUtil;\nimport com.alibaba.excel.EasyExcel;\nimport com.alibaba.excel.ExcelWriter;\nimport com.alibaba.excel.annotation.ExcelProperty;\nimport com.alibaba.excel.support.ExcelTypeEnum;\nimport com.alibaba.excel.write.merge.OnceAbsoluteMergeStrategy;\nimport com.alibaba.excel.write.metadata.WriteSheet;\nimport com.alibaba.excel.write.metadata.WriteTable;\nimport com.alibaba.excel.write.metadata.style.WriteCellStyle;\nimport com.alibaba.excel.write.metadata.style.WriteFont;\nimport com.alibaba.excel.write.style.HorizontalCellStyleStrategy;\nimport com.alibaba.excel.write.style.column.LongestMatchColumnWidthStyleStrategy;\nimport org.apache.poi.ss.usermodel.BorderStyle;\nimport org.apache.poi.ss.usermodel.HorizontalAlignment;\nimport org.apache.poi.ss.usermodel.IndexedColors;\n\nimport java.beans.PropertyDescriptor;\nimport java.io.OutputStream;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.Collectors;\n\n/**\n * @Description EasyExcel导出工具类\n * @Author Kazusa\n */\npublic class EasyExcelUtil {\n\t//在这里新增了一个ThreadLocal类变量，用以存储一个自适应列宽的策略\n    private static final ThreadLocal<LongestMatchColumnWidthStyleStrategy> matchStrategy = new ThreadLocal();\n\n    public void export(OutputStream os, ExportCustomCommon params, List<String> fields) {\n        //获取标题部分数据\n        List<String> headerTable = params.getHeaderTable();\n        //获取公共部分数据\n        ExportCustomCommon.ExcelCommonData commonTable = params.getCommonTable();\n        //获取列表部分数据\n        List<? extends ExportCustomCommon.ExcelListData> listTable = params.getListTable();\n        //获取列表部分数据的类对象\n        Class<? extends ExportCustomCommon.ExcelListData> listDataClass = listTable.get(0).getClass();\n\t\t//每次构建一个新的Excel文件时，新建一个自适应列宽策略对象，并存入ThreadLocal中\n        LongestMatchColumnWidthStyleStrategy matchWidthStrategy = new LongestMatchColumnWidthStyleStrategy();\n        matchStrategy.set(matchWidthStrategy);\n        \n        //构建EasyExcel Writer对象\n        ExcelWriter writer = null;\n\n        try {\n            writer = EasyExcel.write(os, listDataClass)//指定写入的流，以及需要EasyExcel自带动态生成的类的类对象\n                    .excelType(ExcelTypeEnum.XLSX).build();\n            WriteSheet sheet = EasyExcel\n                    .writerSheet(\"sheet1\")//指定写入的sheet\n                    .needHead(false)//是否需要head，也就是每一个字段对应的字段名，这里为不需要，我们需要EasyExcel去生成字段名的地方只有列表数据部分\n                    .build();\n            //使用一个计数器记录当前已经写了几个表格\n            AtomicInteger tableNoCounting = new AtomicInteger(1);\n            //需要知道列数的最大值是多少\n            int maxColumn = fields.size();\n            this.buildHeader(maxColumn, headerTable, sheet, writer, tableNoCounting);\n            this.buildCommon(maxColumn, commonTable, sheet, writer, tableNoCounting);\n            this.buildList(listTable, sheet, writer, tableNoCounting, fields);\n        } finally {\n            assert writer != null;\n            // 关闭流\n            writer.finish();\n            matchStrategy.remove();\n        }\n\n    }\n\n    /**\n     * 构建标题\n     */\n    private void buildHeader(int maxColumn, List<String> headerList, WriteSheet sheet, ExcelWriter writer, AtomicInteger tableNoCounting) {\n        //自定义到处样式\n        WriteCellStyle cellStyle = new WriteCellStyle();\n        //水平居中\n        cellStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);\n        WriteFont writeFont = new WriteFont();\n        //加粗\n        writeFont.setBold(Boolean.TRUE);\n        //字体大小\n        writeFont.setFontHeightInPoints((short) 15);\n        cellStyle.setWriteFont(writeFont);\n        //遍历标题部分的List\n        for (String header : headerList) {\n            WriteTable table = EasyExcel\n                    .writerTable(tableNoCounting.get())//指定写入表格的序号，EasyExcel会将多个表格按照序号从小到大、由上到下的排列\n                    .needHead(Boolean.FALSE)//也不需要标题\n                    .registerWriteHandler(\n                            //合并标题的单元格\n                            new OnceAbsoluteMergeStrategy(tableNoCounting.get() - 1, tableNoCounting.getAndIncrement() - 1, 0, maxColumn - 1)\n                    )\n                    //将自定义样式应用与该表\n                    .registerWriteHandler(new HorizontalCellStyleStrategy(cellStyle, cellStyle))\n                    .build();\n            //在这里，由于EasyExcel使用List<List<String>>这样的数据来构建一个表，里面的List<String>表示一行数据。\n            //所以我们这里一次只构建一行数据，一行数据中只有一个单元格的数据，一行数据就作为一个表格写入\n            //故有几个标题就需要构建几次表格\n            List<String> cellList = new ArrayList<>();\n            cellList.add(header);\n            //因为需要合并单元格到列数最大的单元格处，这里如果不添加空字符串，EasyExcel不会构建单元格，在合并单元格的时候就会报错\n            for (int i = 0; i < maxColumn - 1; ++i) {\n                cellList.add(\"\");\n            }\n            List<List<String>> rowList = new ArrayList<>();\n            rowList.add(cellList);\n            //写入表格\n            writer.write(rowList, sheet, table);\n        }\n    }\n\n    /**\n     * 属性实体类\n     */\n    private static class ExcelField {\n        //属性名\n        private String fieldName;\n        //Excel中显示名\n        private String showName;\n        //排序\n        private int order;\n        //属性值\n        private Object value;\n\n        public String getFieldName() {\n            return fieldName;\n        }\n\n        public void setFieldName(String fieldName) {\n            this.fieldName = fieldName;\n        }\n\n        public String getShowName() {\n            return showName;\n        }\n\n        public void setShowName(String showName) {\n            this.showName = showName;\n        }\n\n        public int getOrder() {\n            return order;\n        }\n\n        public void setOrder(int order) {\n            this.order = order;\n        }\n\n        public Object getValue() {\n            return value;\n        }\n\n        public void setValue(Object value) {\n            this.value = value;\n        }\n    }\n\n    /**\n     * 构建公共部分\n     */\n    private void buildCommon(int maxColumn, ExportCustomCommon.ExcelCommonData commonTable, WriteSheet sheet, ExcelWriter writer, AtomicInteger tableNoCounting) {\n        if (ObjectUtil.isNotEmpty(commonTable)) {\n            //获取公共数据的类对象\n            Class<?> commonDataClass = commonTable.getClass();\n            //通过类对象获取该类中的所有属性\n            List<Field> fields = this.getAllField(commonDataClass);\n            List<ExcelField> fieldList = new ArrayList<>();\n            try {\n                for (Field field : fields) {\n                    //如果在Maven打包时报错，Spring项目中可以替换为Spring中的BeanUtils.getPropertyDescriptor（）\n                    PropertyDescriptor pd = new PropertyDescriptor(field.getName(), commonDataClass);\n                    Assert.notNull(pd, Exception::new);\n                    //反射获取读方法\n                    Method readMethod = pd.getReadMethod();\n                    //读到属性值\n                    Object fieldValue = readMethod.invoke(commonTable);\n                    //获取属性注解\n                    ExcelProperty property = field.getAnnotation(ExcelProperty.class);\n                    //获取Excel显示名称\n                    String excelFieldName = property.value()[0];\n                    //获取Excel中排序\n                    int excelFieldOrder = property.order();\n                    //构建对象\n                    ExcelField excelField = new ExcelField();\n                    excelField.setFieldName(field.getName());\n                    excelField.setShowName(excelFieldName);\n                    excelField.setOrder(excelFieldOrder);\n                    excelField.setValue(fieldValue);\n                    fieldList.add(excelField);\n                }\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n\n            //根据Order排序\n            fieldList.sort(Comparator.comparingInt(ExcelField::getOrder));\n            int count = fieldList.size();\n            //计算一行显示属性的个数，除以3是因为一个属性需要属性名--属性值--空字符串三个单元格\n            int lineCount = maxColumn / 3;\n            //计算行数\n            int rows = (count + lineCount - 1) / lineCount;\n            List<Object> cellList = new ArrayList<>();\n            List<List<Object>> rowList = new ArrayList<>();\n            //自定义样式\n            WriteCellStyle cellStyle = new WriteCellStyle();\n            //水平靠左\n            cellStyle.setHorizontalAlignment(HorizontalAlignment.LEFT);\n            //遍历所有行，一行作为一个表\n            for (int row = 0; row < rows; ++row) {\n                WriteTable table = EasyExcel.writerTable(tableNoCounting.getAndIncrement())\n                        .needHead(Boolean.FALSE)\n                        .registerWriteHandler(\n                                new HorizontalCellStyleStrategy(cellStyle, cellStyle)\n                        )\n                    \t//添加自适应列宽策略\n                        .registerWriteHandler(matchStrategy.get())\n                        .build();\n                //构建List<List<String>>类型的数据给EasyExcel导出\n                for (int i = 0; i < lineCount && row * lineCount + i < count; ++i) {\n                    ExcelField field = fieldList.get(row * lineCount + i);\n                    cellList.add(field.getShowName() + \":\");\n                    cellList.add(field.getValue());\n                    cellList.add(\"\");\n                }\n\n                rowList.add(cellList);\n                //指定写入的sheet和table\n                writer.write(rowList, sheet, table);\n                cellList.clear();\n                rowList.clear();\n            }\n        }\n    }\n\n    /**\n     * 构建列表部分\n     */\n    private void buildList(List<? extends ExportCustomCommon.ExcelListData> listTable, WriteSheet sheet, ExcelWriter writer, AtomicInteger tableNoCounting, List<String> fields) {\n        //自定义样式\n        WriteCellStyle headStyle = new WriteCellStyle();\n        //设置header背景颜色为透明\n        headStyle.setFillForegroundColor(IndexedColors.AUTOMATIC.getIndex());\n        //水平居中\n        headStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);\n        //上下左右四个边框\n        headStyle.setBorderBottom(BorderStyle.THIN);\n        headStyle.setBorderTop(BorderStyle.THIN);\n        headStyle.setBorderLeft(BorderStyle.THIN);\n        headStyle.setBorderRight(BorderStyle.THIN);\n        WriteFont writeFont = new WriteFont();\n        //字体加粗\n        writeFont.setBold(Boolean.TRUE);\n        //字号\n        writeFont.setFontHeightInPoints((short) 12);\n        headStyle.setWriteFont(writeFont);\n        WriteCellStyle contentStyle = new WriteCellStyle();\n        //内容上下左右四个边框\n        contentStyle.setBorderBottom(BorderStyle.THIN);\n        contentStyle.setBorderTop(BorderStyle.THIN);\n        contentStyle.setBorderLeft(BorderStyle.THIN);\n        contentStyle.setBorderRight(BorderStyle.THIN);\n        //水平居中\n        contentStyle.setHorizontalAlignment(HorizontalAlignment.CENTER);\n        WriteTable table = EasyExcel.writerTable(tableNoCounting.getAndIncrement())\n                .needHead(Boolean.TRUE)//需要Header\n            \t//添加自适应列宽策略\n                .registerWriteHandler(matchStrategy.get())\n                .registerWriteHandler(new HorizontalCellStyleStrategy(headStyle, contentStyle))//传入自定义样式\n                .includeColumnFiledNames(fields)//选择需要哪些属性\n                .build();\n        writer.write(listTable, sheet, table);\n    }\n\n    //获取该类的所有属性，包括父类中不重名的属性\n    private List<Field> getAllField(Class<?> clazz) {\n        List<Field> resultList = new ArrayList<>();\n        for (List<String> fieldNameList = new ArrayList<>();\n             clazz != null && !clazz.getName().toLowerCase().equals(ExportCustomCommon.class.getName());\n             clazz = clazz.getSuperclass()) {\n            List<Field> subFields = Arrays.asList(clazz.getDeclaredFields());\n            List<Field> list = subFields.stream()\n                    .filter((f) -> !fieldNameList.contains(f.getName()))\n                    .collect(Collectors.toList());\n            List<String> nameList = list.stream().map(Field::getName).collect(Collectors.toList());\n            resultList.addAll(list);\n            fieldNameList.addAll(nameList);\n        }\n        return resultList;\n    }\n}\n```\n\n看完自适应列宽部分代码的小伙伴应该会有一个疑问，为什么需要使用一个线程本地变量来存储这个策略对象？\n\n就像我们之前说过的该代码导出Excel表格使用了多个Table组合成一个Excel的形式，那么每个table中的每一个单元格都会影响跟它同列但是属于其他Table的列宽，查看`LongestMatchColumnWidthStyleStrategy`的源码可以看到，其内部有一个cache Map，作用就是存储该列的最大长度，从而保证该列上的每一个单元格中的内容都可以显示完全，所以在这里我们需要保证一个Excel文件导出过程中使用的`LongestMatchColumnWidthStyleStrategy`对象为同一个对象。当然不一定使用线程本地变量来存储，也可以使用其他的方法。\n\n```java\npackage com.alibaba.excel.write.style.column;\n\nimport ............\n\npublic class LongestMatchColumnWidthStyleStrategy extends AbstractColumnWidthStyleStrategy {\n\n    private static final int MAX_COLUMN_WIDTH = 255;\n\n    //这里就是存储某一列最大列宽的Map，如果构建同一个Excel时使用了不同的Map，最终的结果会出现错误\n    private Map<Integer, Map<Integer, Integer>> cache = new HashMap<Integer, Map<Integer, Integer>>(8);\n\n    @Override\n    protected void setColumnWidth(WriteSheetHolder writeSheetHolder, List<CellData> cellDataList, Cell cell, Head head,\n        Integer relativeRowIndex, Boolean isHead) {\n        boolean needSetWidth = isHead || !CollectionUtils.isEmpty(cellDataList);\n        if (!needSetWidth) {\n            return;\n        }\n        Map<Integer, Integer> maxColumnWidthMap = cache.get(writeSheetHolder.getSheetNo());\n        if (maxColumnWidthMap == null) {\n            maxColumnWidthMap = new HashMap<Integer, Integer>(16);\n            cache.put(writeSheetHolder.getSheetNo(), maxColumnWidthMap);\n        }\n        Integer columnWidth = dataLength(cellDataList, cell, isHead);\n        if (columnWidth < 0) {\n            return;\n        }\n        if (columnWidth > MAX_COLUMN_WIDTH) {\n            columnWidth = MAX_COLUMN_WIDTH;\n        }\n        Integer maxColumnWidth = maxColumnWidthMap.get(cell.getColumnIndex());\n        if (maxColumnWidth == null || columnWidth > maxColumnWidth) {\n            maxColumnWidthMap.put(cell.getColumnIndex(), columnWidth);\n            writeSheetHolder.getSheet().setColumnWidth(cell.getColumnIndex(), columnWidth * 256);\n        }\n    }\n\n    private Integer dataLength(List<CellData> cellDataList, Cell cell, Boolean isHead) {\n        if (isHead) {\n            return cell.getStringCellValue().getBytes().length;\n        }\n        CellData cellData = cellDataList.get(0);\n        CellDataTypeEnum type = cellData.getType();\n        if (type == null) {\n            return -1;\n        }\n        switch (type) {\n            case STRING:\n                return cellData.getStringValue().getBytes().length;\n            case BOOLEAN:\n                return cellData.getBooleanValue().toString().getBytes().length;\n            case NUMBER:\n                return cellData.getNumberValue().toString().getBytes().length;\n            default:\n                return -1;\n        }\n    }\n}\n```\n\n最后导出的结果如图：\n\n![Excel导出实例-自适应列宽](image-20230606135154929.png)\n\n最后，本代码只实现了列表部分可以选择字段导出，在公共部分没有办法选择指定字段导出，但是由于整个Excel都是动态生成的，在构建公共部分表格时只需要把公共部分的字段自己做一个筛选即可。\n\n","tags":["test","test2"],"categories":["tc1","tc2"]},{"title":"Hello World","url":"/2024/03/01/hello-world/","content":"添加说明\n\n<!-- more -->\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]